import os
import json
import random
import subprocess
import sys
import shutil
import hashlib
import itertools

from upm_iface import y


def install_dir(pkg):
    try:
        pkg['idir']
    except KeyError:
        pkg['idir'] = '$(WDP)/' + y.to_visible_name(pkg)

    return pkg['idir']


def bin_dir(pkg):
    return install_dir(pkg) + '/bin'


def lib_dir(pkg):
    return install_dir(pkg) + '/lib'


def inc_dir(pkg):
    return install_dir(pkg) + '/include'


@y.cached(key=lambda x: x['noid'])
def get_subst_values_3(root):
    def mn(x):
        return '$(WDM)' + x[6:]

    def iter1():
        yield root

    def do():
        for x in itertools.chain(iter1(), root['deps']()):
            for n in [x['node']()['name']]:
                if n:
                    n = n.upper().replace('-', '_')

                    yield ('$(MNGR_' + n + '_DIR)', mn(install_dir(x)))
                    yield ('$(MNGR_' + n + '_BIN_DIR)', mn(bin_dir(x)))
                    yield ('$(MNGR_' + n + '_LIB_DIR)', mn(lib_dir(x)))
                    yield ('$(MNGR_' + n + '_INC_DIR)', mn(inc_dir(x)))

    return list(do())


def subst_values(data, root):
    root_node = root['node']()

    def iter1():
        pkg_root = gen_pkg_path(root)

        yield ('$(INSTALL_DIR)', '$(WDP)/' + pkg_root[7:])
        yield ('$(BUILD_DIR)', '$(WDW)/' + root['noid'][2:])
        yield ('$(PYTHON)', '/usr/bin/python')
        yield ('$(PKG_FILE)', pkg_root)

    def iter2():
        if 'url' in root_node:
            cmd = y.prepare_untar_cmd('$(MNGR_FETCH_URL_DIR)/' + root_node['pkg_full_name'], '.', extra='--strip-components {level}')

            yield ('$(FETCH_URL)', cmd.format(level='1'))
            yield ('$(FETCH_URL_2)', cmd.format(level='2'))
            yield ('$(FETCH_URL_FILE)', 'ln $(MNGR_FETCH_URL_DIR)/$(URL_BASE) $(URL_BASE)')
            yield ('$(URL)', root_node['url'])
            yield ('$(URL_BASE)', root_node['pkg_full_name'])

    return y.subst_kv_base(data, iter1(), iter2(), get_subst_values_3(root))


def mgr_pkg(x):
    return x.replace('$(WDR)', '$(WDM)') + '/done_mark'


def gen_pkg_path(v):
    return '$(WDR)/' + y.to_visible_name(v)


def build_makefile_impl(nodes, replaces):
    def iter_nodes():
        for n in y.visit_nodes(nodes):
            yield n
            yield y.gen_unpack_node(gen_pkg_path(y.restore_node(n)))

    full = list(iter_nodes())
    by_name = {}

    for ptr in full:
        root = y.restore_node(ptr)
        node = root['node']()
        nnn = node['name']
        cc = node.get('constraint', {})

        def iter_groups():
            yield 'all'
            yield nnn
            x = nnn + '-' + y.short_const_1(cc.get('host', {}))
            yield x
            yield x + y.short_const_1(cc.get('target', {}))

        for name in iter_groups():
            name = name.replace('_', '-')

            if name in by_name:
                by_name[name].append(gen_pkg_path(root))
            else:
                by_name[name] = [gen_pkg_path(root)]

    def iter_nodes():
        for ptr in full:
            root = y.restore_node(ptr)
            data = print_one_node(root)
            link = y.to_visible_name(root)
            replaces[link] = hashlib.md5(data).hexdigest()[:8] + link[8:]

            yield data

    def iter_by_name():
        for name in sorted(by_name.keys()):
            yield name + ': ' + ' '.join(sorted(set(by_name[name])))

    def iter_parts():
        yield '## generated by ' + y.script_path()
        yield 'SHELL=/bin/sh'
        yield '\n'

        for n in iter_nodes():
            yield n

        for n in iter_by_name():
            yield n

    return '\n'.join(iter_parts()) + '\n'


def uniq_deps(iter):
    visited = set()

    for x in iter:
        p = gen_pkg_path(x)

        if p not in visited:
            visited.add(p)

            yield (p, x)


def rmmkcd(q, suffix=''):
    return 'rm -rf {q} || true; mkdir -p {q}{s}; cd {q}{s}'.format(q=q, s=suffix)


def prepare_prologue():
    def iter_env(n):
        env1 = [
            ('TMPDIR', '"$(BUILD_DIR)"'),
            ('IDIR', '"$(INSTALL_DIR)"'),
            ('BDIR', '"$(BUILD_DIR)"'),
        ]

        env2 = [
            ('SHELL', '"/bin/sh"'),
            ('LC_ALL', '"C"'),
            ('LANG', '"C"'),
            ('HOME', '"/"'),
            ('PWD', '"/"'),
        ]

        for k, v in [env1, env2][n]:
            yield 'export ' + k + '=' + v

    yield 'set_path $(MNGR_BUILD_SCRIPTS_RUN_BIN_DIR):/bin:/usr/bin:/usr/local/bin'
    yield '; '.join(iter_env(0))
    yield '(for i in "$IDIR" "$BDIR"; do source rmmkcd $i; done) && mkdir $IDIR/log && source mkcd $BDIR/runtime; cat > run.sh; exec $(SHELL) $(SHELL_FLAGS) run.sh'
    yield 'set -ex -o pipefail; exec 1> $BDIR/runtime/stdout.log; pwd;'
    yield '; '.join(iter_env(1))
    yield 'cd /; /usr/bin/env;'


@y.singleton
def node_prologue():
    return list(prepare_prologue())


@y.singleton
def node_epilogue():
    def iter_epi():
        yield 'source last_log $BDIR/runtime/stdout.log'
        yield 'source rmdel $IDIR $BDIR'

    return list(iter_epi())


def print_internal_node(root):
    n = root['node']()
    d = os.path.dirname(n['output'])

    def iter_lines():
        yield n['output'] + ': ' + ', '.join(n['inputs'])

        for l in n['build']:
            yield '\t' + l

    return '\n'.join(iter_lines()) + '\n\n'


def print_one_node(root):
    root_node = root['node']()

    if root_node.get('internal', False):
        return print_internal_node(root)

    target = gen_pkg_path(root)
    nodes = list(uniq_deps(root['deps']()))
    naked = root_node.get('naked', False)

    def iter_part1():
        yield target + ': ' + ' '.join([x[0] for x in nodes] + [mgr_pkg(x[0]) for x in nodes]) + ' ## node ' + root['noid']

        if not naked:
            for l in node_prologue():
                yield l

        for pkg_path, x in nodes:
            xnode = x['node']()
            pdir = pkg_path.replace('$(WDR)', '$(WDM)')
            prepare = xnode.get('prepare', [])

            for p in prepare:
                yield p.replace('$(ADD_PATH)', 'add_path $(CUR_DIR)/bin').replace('$(CUR_DIR)', pdir)

        bld = root_node['build']

        if bld:
            if not naked:
                yield 'cd $BDIR'

            for x in bld:
                yield x

            yield 'source copy_logs $BDIR/runtime/stdout.log $BDIR/config.log $IDIR/log'

        for l in y.prepare_tar_cmd('$IDIR', '$(PKG_FILE)', root_node['codec']):
            yield l

        if not naked:
            for l in node_epilogue():
                yield l

    def iter_part2():
        def get_path(x):
            return x[8:].strip()

        lines1 = []
        paths = []
        lines2 = []

        for l in iter_part1():
            ll = l.strip()

            if ll.startswith('set_path') or ll.startswith('add_path'):
                paths.append(ll)
            else:
                if paths:
                    lines2.append(l)
                else:
                    lines1.append(l)

        for l in lines1:
            yield l

        yield 'export PATH=' + ':'.join([get_path(x) for x in reversed(paths)])

        for l in lines2:
            yield l

    def iter_lines():
        it = iter_part2()

        for l in it:
            yield l

            for x in it:
                yield '\t' + x

        yield ''
        yield ''

    data = '\n'.join(iter_lines())

    for i in (1, 2):
        data = subst_values(data, root)

    return data


def build_makefile(nodes, verbose):
    replaces = {}
    data = build_makefile_impl(nodes, replaces)

    for k, v in y.COLOR_MAP.items():
        if k =='reset':
            repl = '$(U)'
            val = str(" && echo '" + v + "'")
        else:
            repl = '$(' + k[0].upper() + ')'
            val = str("echo '" + v + "' && ")

        replaces[repl] = val

    return y.subst_kv_base(data, replaces.iteritems())
